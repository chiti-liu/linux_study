## 中断

FreeRTOS的核心有个tick中断，是让同等优先级任务时间片轮转调度用的，每过一个tick就调度下一个任务，让每个任务都能得到执行。

所以消息队列等有关任务调度切换、同步互斥等都需要关闭中断，处理完在开中断。



## 栈

### 汇编说明

> push {r3, lr}，无论怎么排，r3都在低地址。sp=lr,sp-4;sp=r3,sp-4
>
> 低标号寄存器保存在低地址，高标号寄存器保存在高地址 

> pop {r3,pc}   r3=sp,sp+4;pc=sp,sp+4

> LDR  r1,[#1234], 把1234内存中的数据放入r1寄存器
>
> STR  r2,[#1234],把寄存器r2的值存入1234内存



### 切换和保护现场

任务切换要保存所有的寄存器

硬件中断，硬件会帮忙保存r0~r2寄存器，软件再保存一部分寄存器

子函数切换  r0~r2无需保存，任务切换需要用到psp之间，在xPortPendSVHandler中完成保护现场和psp切换，切换好硬件会主动pop下一个任务。

##  MSP和PSP

msp主堆栈给main和中断使用，psp给任务使用，

![image-20220314104609980](D:\typora\picture\进程堆栈描述1.png)

![进程堆栈描述2](D:\typora\picture\进程堆栈描述2.png)![image-20220314104950115](D:\typora\picture\进程堆栈描述3.png)

![image-20220314105024730](D:\typora\picture\进程堆栈描述4.png)



## 时间片轮转和抢占式任务

同等优先级时间片轮转调度，不同优先级抢占式调度

空闲任务优先级为0，它在任务调度函数vtaskscheduler()调用后开启，如果队长大于1，则为其他任务让路。

### 抢占机制

 在抢占式操作系统中，高优先级任务是不会等待低优先级任务彻底执行完毕后，通过调度器切换任务而获得CPU使用权，而是高优先级任务的就绪条件一满足就会立刻夺过CPU的使用权，暂时中断正在执行的低优先级任务，但CPU在执行低优先级任务时，是如何实时知道高优先级任务就绪了呢，由结果倒推原因，那就是CPU不是一直特别专一的只执行低优先级任务，而是有一个大扫描，会实时检测高优先级任务的运行条件是否已满足，一旦满足就会发生抢占事件，否则继续执行低优先级任务。

 其实仔细研究过操作系统后便知，这是操作系统的任务切换机制，操作系统跟人一样必须有一个心跳，整个系统按照这个心跳有序正确的工作，这个心跳就是系统时钟，系统时钟一般是由定时器产生，每隔一定时间便产生一次中断，系统便在这个中断里做一些事情，这当中就包括调度器的任务切换，即一次中断到来后便检测高优先级任务的就绪条件是否满足，条件满足则切换任务，不满足则继续执行当前任务，这就在现象上表现出，操作系统能实时知道高优先级任务何时就绪了，以便切换到高优先级任务而执行。

## 链表

### readylist

#### 多少个优先级多少个链表

从高优先级往低优先级链表查询，空闲任务一直礼让（YIELD（）），高优先级抢占低优先级1。

是否抢占和时间片轮转都由宏定义实现。

如果都不抢占不时间片轮转呢？

答：会执行最高优先级那个，如果是0优先级，则运行下一个0优先级（即空闲本身是最后一个，下一个就是第一个任务）

### delaylist

#### 只有一个链表

和阻塞一类

### suspendlist

#### 只有一个链表

挂起

## 消息队列核心

资源共享，可阻塞可不阻塞，依据参数设定

### 关中断 

互斥

### 环形缓冲区

存储数据，不断更新

###   链表

插入和唤醒

队列heap=队列头+环形缓冲区

## 信号量核心

有限资源共享访问权限,实质还是个队列，只是信号量不阻塞

### 关中断

### count

资源允许访问的次数

### list

只有队列头，data为0

## 互斥量核心

### 关中断

### 二值

只有0和1

### 优先级反转与继承

获取mutex失败就会提升mutex拥有者优先级，等拥有者释放完就回复自己原有优先级

## 事件核心

### 关调度器

不会在中断中使用事件组，但会在中断中回调事件处理任务，但因为任务时间的不确定性，所以任务在中断外执行，所以就要在事件创建中屏蔽其他任务的执行。

### 位操作

可以选择|&来决定事件发生的条件是多个任务一起，还是只要有一个任务发生就符合条件，另外还可以在判断符合条件并且处理完事件后要不要把这些标志位复位。

### 链表

阻塞的话还可能需要保存好标志自己的链表

## 任务通知

任务通知和事件唤醒差别

任务通知：不管接收方怎样  我发出了，改写了这个状态，你就必须要作出相应的事件。

事件唤醒：接受方能够根据接收到的数据判断是否符合预期唉决定是否处理。

核心和事件的差不多，只是位可能变成了值。

## TCB

process control block

## 软件定时器

### 链表



### 周期

### 函数

## 中断

### A类中断

freertos的API不能调用

### B类中断

可以使用freertos的API，就是他自己占有的中断优先级是B类，比A类优先级低，保证了一些紧急任务的处理，让出优先级给其他硬件

* 函数后面加fromISR就是适用于中断的

- 很多API函数会导致任务计入阻塞状态：
  - 运行这个函数的**任务**进入阻塞状态
  - 比如写队列时，如果队列已满，可以进入阻塞状态等待一会
- ISR调用API函数时，ISR不是"任务"，ISR不能进入阻塞状态
- portdisable_interrupets()用来关中断，但关的是B类中断
