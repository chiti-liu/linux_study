union

{

struct stu

{

uint_8 num:1;

uint_8 num2:3;

uint_8 num3:1;

uint_8 num4:3;

}num;

   uint_8 nums;

};

位域一般用在usigned int and signed int ，不过编译器如果对char作int 优化的话可以支持

struct内存对齐以最大数据量作为存储块。

大小端问题：

以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value：

　　Big-Endian: 低地址存放高位，如下：

高地址

​    \---------------

​    buf[3] (0x78) -- 低位

​    buf[2] (0x56)

​    buf[1] (0x34)

​    buf[0] (0x12) -- 高位

​    \---------------

​    低地址

Little-Endian: 低地址存放低位，如下：

高地址

​    \---------------

​    buf[3] (0x12) -- 高位

​    buf[2] (0x34)

​    buf[1] (0x56)

​    buf[0] (0x78) -- 低位

​    \--------------

低地址

内存池的分配有三点：保证内存分配的线程安全（用互斥体保证改写的头部数据的安全）、静态内存区的分配（如果内存区不够再用malloc），动态调取分配内存（保证了最大限度的利用静态内存区，减少内存碎片）。

用了malloc/realloc必须用free，new必须delete, malloc在小容量ram中分配不连续存储空间要考虑heap的大小，容易造成内存碎片。Malloc有必要进行申请检查（特别是大项目，不然heap空间不够而你出bug一时查不出哪里错了），而且free传入的是指针，销毁的是堆上的内容，只是那段空间不用了，而不是指针，指针还是指向这段内存，指针之后也需要赋值null。内存碎片也不用太担心，只要不是频繁操作heap，那么系统就有足够的时间来回收。

内存管理的意识很重要。

用strncpy, strncat, sscanf , fgets替代 strcpy, strcat , scanf, gets。

 

Char *p = “asd”,q[]=”asd”;

Extern char *p;//可以正常访问，p的地址和数据地址不同，p存储的是数据地址，访问指针包含的数据（地址）。

Extern char *q;//不可以正常访问，q本身地址就是数据的地址，他的内容就是数据，访问的话会把q的数据内容当做地址去访问。

 

Extern p[];//不可以正常访问，存储的是数据地址，那么表达出来的就是地址。

Extern q[];//可以正常访问，表达数据。

 

Getchar()、fgets()等函数函数值需要用int来接收。Char等类型可以想一下返回值会发生数据截断。

\#define NULL ((void *)0)**//****注意这个两层括号，一定要的规则。**

指针被free或者delete后，指针不知道指向哪里（可能指向原位或者乱七八糟），内容不知道指向了什么，所以要把指针重新指向空作为空指针，但最好不要再次访问，而且free或者delete时要从底层往高层删除。

C语言中的___FILE___用以指示本行语句所在源文件的文件名（%s）

\#line 200  //指定下一行的__LINE__为200

__LINE__    //指定所在行号

__func__  //指示所在函数

注意 “#line”、 “__LINE__”、 “__FILE__" 及 “__func__" 都是大小写敏感的。

 

1.内联函数的函数体内不能含有复杂的结构控制语句，如switch和while，否则编译器将该函数视同普通函数那样产生函数调用代码。

2.递归函数不能被用来作为内联函数。

3.内联函数一般适合于只有1-5行语句的小函数，对于一个含有很多语句的大函数，没必要使用内联函数来实现。

4.内联函数的定义必须出现在内联函数第一次被调用之前。

5.对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。

_inline函数也称为内联函数或内嵌函数，_inline定义的类的内联函数，函数代码被放入符号调用表，使用时直接展开，不需要调用，即在编译期间将所调用的函数的代码直接嵌入到主调函数中，是一种以空间换时间的函数。

1、首先，inline函数是不能像传统的函数那样放在.c中然后在.h中给出接口在其余文件中调用的,

因为inline函数其实是跟宏定义类似，不存在所谓的函数入口。

2、因为第一点，会出现一个问题，就是说如果inline函数在两个不同的文件中出现，也就是说

一个.h被两个不同的文件包含，则会出现重名，链接失败

所以static inline 的用法就能很好的解决这个问题，

使用static修饰符，函数仅在文件内部可见，不会污染命名空间。

可以理解为一个inline在不同的.C里面生成了不同的实例，而且名字是完全相同的

inline函数的注意事项

一般写在.c文件头部中

只在release版本生效

给编译器的一个建议，循环、递归、switch一定不会出现在inline。

inline基于实现，不是基于声明，即在声明点无效（先声明后内联）

Linux常用函数

1.char *getenv(const char *name)

参数

name -- 包含被请求变量名称的字符串。

返回值

返回一个以 null 结尾的字符串，该字符串为被请求环境变量的值。如果该环境变量不存在，则返回 NULL。

\2. int putenv(const char * string);

putenv()用来改变或增加环境变量的内容。参数string的格式为name＝value，如果该环境变量原先存在，则变量内容会依参数string改变，否则此参数内容会成为新的环境变量。

\3. int setenv(const char *name,const char * value,int overwrite);

setenv()用来改变或增加环境变量的内容。参数name为环境变量名称字符串。

参数

value则为变量内容，参数overwrite用来决定是否要改变已存在的环境变量。如果overwrite不为0，而该环境变量原已有内容，则原内容会被改为参数value所指的变量内容。如果overwrite为0，且该环境变量已有内容，则参数value会被忽略。

putenv 函数和 setenv 函数虽然功能类似，但是这两个函数在实现方面还是有区别的，区别如下：

putenv函数：

putenv 函数会将参数 string 直接填写到环境表中，不会再为 "name=value" 这个字符串再去分配内存。如果是在一个函数中定义的string，那么在调用该函数后，string 指向的内容可能会被释放，就找不到name环境变量的值了。

//实验结果setenv可以在屏幕上显示变量改变后的结果，而putenv则显示的还是原来的值

setenv 函数：

setenv 函数和 putenv 函数不同，它会将name和value指向的内容复制一份并为其分配内存，形成 "name=value" 的字符串，并将其地址写入到环境表中。所以就不会出现上面putenv 的情况，就算函数返回了，name 和 value指向的内容被释放了，仍然有一份拷贝在。

 

itoa():

将整型值转换为字符串

头文件stdio.h 或 stdlib.h

itoa()函数有3个参数：

第一个参数是要转换的数字，

第二个参数是要写入转换结果的目标字符串，

第三个参数是转移数字时所用 的基数。转换基数为10。10：十进制；2：二进制...

itoa并不是一个标准的C函数，它是Windows特有的，如果要写跨平台的程序，请用sprintf。可以跟sprintf相互使用。

C语言实现：

char* itoa(int num,char* str,int radix)

{/*索引表*/

  char index[]="0123456789ABCDEF";

  unsigned unum;/*中间变量*/

  int i=0,j,k;

  /*确定unum的值*/

  if(radix==10&&num<0)/*十进制负数*/

  {

​    unum=(unsigned)-num;

​    str[i++]='-';

  }

  else unum=(unsigned)num;/*其他情况*/

  /*转换*/

  do{

​    str[i++]=index[unum%(unsigned)radix];

​    unum/=radix;

​    }while(unum);

  str[i]='\0';

  /*逆序*/

  if(str[0]=='-')

​    k=1;/*十进制负数*/

  else

​    k=0;

  for(j=k;j<=(i-1)/2;j++)

  {    char temp;

​    temp=str[j];

​    str[j]=str[i-1+k-j];

​    str[i-1+k-j]=temp;

  }

  return str;

}

atoi():

把字符串转换成整型

C语言实现：

int my_atoi(const char *src)

{

   int s = 0;

   bool isMinus = false;

   while(*src == ' ') //跳过空白符

   {

​     src++; 

   } 

   if(*src == '+' || *src == '-')

   {

​     if(*src == '-')

​     {

​        isMinus = true;

​     }

​     src++;

   }

   else if(*src < '0' || *src > '9') //如果第一位既不是符号也不是数字，直接返回异常值

   {

​     s = 2147483647;

​     return s;

   } 

   while(*src != '\0' && *src >= '0' && *src <= '9')

   {

​      s = s * 10 + *src - '0';

​     src++;

   }

   return s * (isMinus ? -1 : 1);

 }

 

fgets：从文件中读取一行数据存入缓冲区（fgets遇到回车才会结束，不对空格和换行做任何转换就录入到缓冲区，结束后再往缓冲区写多一个\0，所以它是读一行数据）

 

fscanf：从文件中读取一段数据存入缓冲区（fscanf遇到空格或回车就结束，它会把空格或回车转换为\0，所以它是读一小段数据）

 

\#include <unistd.h>

int execve(const char *filename, char *const argv[], char *const envp[]);

filename必须是一个二进制的可执行文件，或者是一个脚本以#！格式开头的解释器参数。如果是后者，这个解释器必须是一个可执行的有效的路径名，但是不是脚本本身，它将调用解释器作为文件名。

argv是要调用的程序执行的参数序列，也就是我们要调用的程序需要传入的参数。

envp 同样也是参数序列，一般来说他是一种键值对的形式 key=value. 作为我们是新程序的环境。

例：

\#include<stdio.h>

\#include<unistd.h>

int main(int arg, char **args)

{

  char *argv[]={"ls","-al","/home/chicho/result/", NULL};

  char *envp[]={0,NULL}; //传递给执行文件新的环境变量数组

  execve("/bin/ls",argv,envp);

}

这个程序的功能就是使用ls 查看我们/home/chicho/result下面的文件夹的内容。

system 是在单独的进程中执行命令，完了还会回到你的程序中。而exec函数是直接在你的进程中执行新的程序，新的程序会把你的程序覆盖，除非调用出错，否则你再也回不到exec后面的代码，就是说你的程序就变成了exec调用的那个程序了。

 

strchr()函数包含于头文件：#include<string.h>中； 

函数原型为：char * strchr(char * str, char/int c);

 

函数功能为：在字符串str中寻找字符C第一次出现的位置，并返回其位置（地址指针），若失败则返回NULL；

文件IO

文件流分二进制和文本流

原型: feof(FILE *fp); 检测是否到达文件结尾,如果到达返回非零值,否则返回零.

原型: ferror(FILE *fp);发生读写错误,返回一个非零值,否则返回零值.

assert 断言不可逻辑判断，只能判断原有的合理性

 

C 库函数 char *strtok(char *str, const char *delim) 分解字符串 str 为一组字符串，delim 为分隔符。

如：

char str[80] = "This is - www.runoob.com - website";

  const char s[2] = "-";

  char *token;

  

  /* 获取第一个子字符串 */

  token = strtok(str, s);

  

  /* 继续获取其他的子字符串 */

  while( token != NULL ) {

   printf( "%s\n", token );

   token = strtok(NULL, s);

  }

输出：

This is 

 www.runoob.com 

 website

 

void * memcpy（void * restrict s1, const void * restrict s2, size_t n);

void * memmove(void * s1, const void * s2, size_t n);

这两个函数均从s2指向的位置复制n字节数据到s1指向的位置，且均返回s1的值。两者之间的差别由关键字restrict造成，即memcpy()可以假定两个内存区域没有重叠。memmove()函数则不做这个假定，因此，复制过程类似于首先将所有字节复制到一个临时缓冲区，然后再复制到最终目的地。如果两个区域存在重叠时使用memcpy()会怎样？其行为是不可预知的，既可以正常工作，也可能失败。在不应该使用memcpy()时，编译器不会禁止使用memcpy()。因此，使用memcpy()时，您必须确保没有重叠区域。这是程序员的任务的一部分。 [2] 

关键字restrict有两个读者。一个是编译器，它告诉编译器可以自由地做一些有关优化的假定。另一个读者是用户，他告诉用户仅使用满足restrict要求的参数。一般，编译器无法检查您是否遵循了这一限制，如果您蔑视它也就是在让自己冒险。

 

**头文件避免不必要的编译，防止过多依赖，每个子模块对应一个头文件。**

依赖关系会进行传导，如x.h包含y.h，而y.h又包含了z.h，则x通过y依赖了z。依赖将导致编译时间的上升。虽然依赖是不可避免的，也是必须的，但是不良的设计会导致整个系统的依赖关系无比复杂，使得任意一个文件的修改都要重新编译整个系统，导致编译时间巨幅上升。

在一个设计良好的系统中，修改一个文件，只需要重新编译数个，甚至是一个文件。

若包含了头文件aa.h，则就引入了新的依赖：一旦aa.h被修改，任何直接和间接包含aa.h代码都会被重新编译。

原则1.1 头文件中适合放置接口的声明，不适合放置实现。

定义尽量放在源文件中，这里一般放置要用到的函数和重定义。

原则1.2 头文件应当职责单一。

不要包含那种：过多使用而没有必要的变量或者重定义等。如：

typedef unsigned short WORD;只会增加编译负担

原则1.3 头文件应向稳定的方向包含。

头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。

就我们的产品来说，依赖的方向应该是：产品依赖于平台，平台依赖于标准库。

规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。 

说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。

static void bar();//注意要在源文件中加上static声明

void foo()

{

 bar();

}

规则1.2 禁止头文件循环依赖。

规则1.3 .c/.h文件禁止包含用不到的头文件。

规则1.4 头文件应当自包含。

简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。

规则1.5 总是编写内部#include保护符（#define 保护）。

\#ifndef VOS_INCLUDE_TIMER_TIMER_H 

\#define VOS_INCLUDE_TIMER_TIMER_H 

... 

\#endif

例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符(#ifndef XX_H)前面。

规则1.6 禁止在头文件中定义变量。

规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。 

说明：若a.c使用了b.c定义的foo()函数，则应当在b.h中声明extern int foo(int input)；并在a.c中通过#include <b.h>来使用foo。禁止通过在a.c中直接写extern int foo(int input);来使用foo，后面这种写法容易在foo改变时可能导致声明和定义不一致。

规则1.8 禁止在extern "C"中包含头文件。

在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏。禁止这种危险行为。

\#ifndef B_H__ 

\#define B_H__ 

\#ifdef __cplusplus //而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件)

extern "C" { //在CPP中，这段只以C方式编译

//这里可以放C类型的.h文件，但最好放在前面，保证规则

\#endif

\#include "a.h"（C++类型）//错误，必须放在extern”c”之前，不然编译规则被不正确的修改了。

 void b(); 

\#ifdef __cplusplus 

} 

\#endif

建议1.1 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名。

建议1.2 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。 

说明：降低接口使用者的编写难度。

建议1.3 头文件不要使用非习惯用法的扩展名，如.inc。

在使用.inc作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。但是从产品的实际代码来看，这一条并没有被遵守，一个.inc文件被多个.c包含比比皆是。

除此之外，使用.inc还导致source insight、Visual stduio等IDE工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫IDE识别.inc为头文件，但是有些软件无法配置，如Visual Assist只能识别.h而无法通过配置识别.inc。

建议1.4 同一产品统一包含头文件排列方式。

示例1：

以升序方式排列头文件可以避免头文件被重复包含，如：

\#include <a.h>

\#include <b.h>

\#include <c/d.h>

\#include <c/e.h>

\#include <f.h>

示例2：

以稳定度排序，建议将不稳定的头文件放在前面，如把产品的头文件放在平台的头文件前面，如下：

\#include <product.h>

\#include <platform.h>

相对来说，product.h修改的较为频繁，如果有错误，不必编译platform.h就可以发现product.h的错误，可以部分减少编译时间。

**函数设计的精髓：编写整洁函数，同时把代码有效组织起来。**

代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。

原则2.1 一个函数仅完成一件功能。

案例：realloc。在标准C语言中，realloc是一个典型的不良设计。这个函数基本功能是重新分配内存。

但它承担了太多的其他任务：如果传入的指针参数为NULL就分配内存，如果传入的大小参数为0就释放内存，如果可行则就地重新分配，如果不行则移到其他地方分配。如果没有足够可用的内存用来完成重新分配（扩大原来的内存块或者分配新的内存块），则返回NULL，而原来的内存块保持不变。这个函数不易扩展，容易导致问题。例如下面代码容易导致内存泄漏：

char *buffer = (char *)malloc(XXX_SIZE);;

buffer = (char *)realloc(buffer, NEW_SIZE);

如果没有足够可用的内存用来完成重新分配，函数返回为NULL，导致buffer原来指向的内存被丢失。

原则2.2 重复代码应该尽可能提炼成函数。

规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。

说明：本规则仅对新增函数做要求，对已有函数修改时，建议不增加代码行。

例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。

延伸阅读材料：业界普遍认为一个函数的代码行不要超过一个屏幕，避免来回翻页影响阅读；一般的代码度量工具建议都对此进行检查，例如Logiscope的函数度量："Number of Statement" （函数中的可执行语句数）建议不超过20行，QA C建议一个函数中的所有行数（包括注释和空白行）不超过50行。

规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。

说明：本规则仅对新增函数做要求，对已有的代码建议不增加嵌套层次。

函数的代码块嵌套深度指的是函数中的代码控制块（例如：if、for、while、switch等）之间互相包含的深度。每级嵌套都会增加阅读代码时的脑力消耗，因为需要在脑子里维护一个“栈”（比如，进入条件语句、进入循环„„）。应该做进一步的功能分解，从而避免使代码的阅读者一次记住太多的上下文。

示例：如下代码嵌套深度为5。

void serial (void) { 

 if (!Received) 

 {

 TmoCount = 0;

 switch (Buff)

 {

   case AISGFLG: 

 if ((TiBuff.Count > 3)

 && ((TiBuff.Buff[0] == 0xff) || (TiBuf.Buff[0] == CurPa.ADDR))) 

   {

   Flg7E = false;

   Received = true;

   }

   else 

 {

   TiBuff.Count = 0;

   Flg7D = false;

   Flg7E = true;

   }

   break;

 default:

   break;

 }

 } }

规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。

int g_exam;

unsigned int example( int para )

{

 unsigned int temp;

 [申请信号量操作] // 若申请不到“信号量”，说明另外的进程正处于

 g_exam = para; //给g_exam赋值并计算其平方过程中（即正在使用此

 temp = square_exam( ); // 信号），本进程必须等待其释放信号后，才可继续执行

[释放信号量操作]。//其它线程必须等待本线程释放信号量后才能再使用本信号。

 return temp;

}

规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。

缺省由调用者负责。

规则2.5 对函数的错误返回码要全面处理。

说明：一个函数（标准库中的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，调用程序应该在函数返回时立刻检查错误指示。

说明：一个函数（标准库中的函数/第三方库函数/用户定义的函数）能够提供一些指示错误发生的方法。这可以通过使用错误标记、特殊的返回数据或者其他手段，不管什么时候函数提供了这样的机制，

调用程序应该在函数返回时立刻检查错误指示。

示例：下面的代码导致宕机

FILE *fp = fopen( "./writeAlarmLastTime.log","r");

 if(fp == NULL) 

 {

 return;

 }

char buff[128] = "";

fscanf(fp,“%s”, buff); /* 读取最新的告警时间；由于文件writeAlarmLastTime.log为空，导致buff为空 */

fclose(fp);

long fileTime = getAlarmTime(buff); /* 解析获取最新的告警时间；getAlarmTime函数未检查buff指针，导致宕机 */

正确写法：

FILE *fp = fopen( "./writeAlarmLastTime.log","r");

 if(fp == NULL) 

 {

 return; }

char buff[128] = "";

if (fscanf(fp,“%s”,buff) == EOF) //检查函数fscanf的返回值，确保读到数据

{

fclose(fp);

 return;

 } 

fclose(fp);

long fileTime = getAlarmTime(buff); //解析获取最新的告警时间；

规则2.6 设计高扇入，合理扇出（小于7）的函数。

说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。

扇出太大，一般是由于缺乏中间层次，可适当增加中间层次的函数。

扇出太小，可把下级函数进一步分解多个函数，或合并到上级函数中。当然分解或合并函数时，不能改变要实现的功能，也不能违背函数间的独立性。

扇入越大，表明使用此函数的上级函数越多，这样的函数使用效率高，但不能违背函数间的独立性而单纯地追求高扇入。公共模块中的函数及底层函数应该有较高的扇入。

较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。

规则2.7 废弃代码（没有被调用的函数和变量)要及时清除。

建议2.1 函数不变参数使用const。

建议2.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用。

说明：带有内部“存储器”的函数的功能可能是不可预测的，因为它的输出可能取决于内部存储器（如某标记）的状态。这样的函数既不易于理解又不利于测试和维护。

在C语言中，函数的static局部变量是函数的内部存储器，有可能使函数的功能不可预测，然而，当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类，则返回为错针。

示例：如下函数，其返回值（即功能）是不可预测的。

unsigned int integer_sum( unsigned int base )

{

 unsigned int index;

 static unsigned int sum = 0;// 注意，是static类型的。

 // 若改为auto类型，则函数即变为可预测。

 for (index = 1; index <= base; index++)

 {

 sum += index;

 }

 return sum;

}

建议2.3 检查函数所有非参数输入的有效性，如数据文件、公共变量等。

说明：函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，应进行有效性检查。

示例：下面的代码导致宕机

hr = root_node->get_first_child(&log_item); // list.xml 为空，导致读出log_item为空

…..

hr = log_item->get_next_sibling(&media_next_node); // log_item为空，导致宕机

正确写法：确保读出的内容非空。

hr = root_node->get_first_child(&log_item); 

…..

if (log_item == NULL) //确保读出的内容非空

{

 return retValue;

}

hr = log_item->get_next_sibling(&media_next_node);

建议2.4 函数的参数个数不超过5个。 

说明：函数的参数过多，会使得该函数易于受外部（其他部分的代码）变化的影响，从而影响维护工作。函数的参数过多同时也会增大测试的工作量。

函数的参数个数不要超过5个，如果超过了建议拆分为不同函数

建议2.5 除打印类函数外，不要使用可变长参函数。 

说明：可变长参函数的处理过程比较复杂容易引入错误，而且性能也比较低，使用过多的可变长参函数将导致函数的维护难度大大增加。

建议2.6 在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字。 

说明：如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了和其他文件或库中的相同标识符发生混淆的可能性。

 

argument (实参)可缩写为 arg  

buffer 可缩写为 buff

clock 可缩写为 clk

command 可缩写为 cmd

compare 可缩写为 cmp

configuration (配置、结构)可缩写为 cfg

device 可缩写为 dev

error 可缩写为 err

hexadecimal 可缩写为 hex

increment 可缩写为 inc、

initialize 可缩写为 init

maximum 可缩写为 max

message 可缩写为 msg

minimum 可缩写为 min

parameter 可缩写为 para

previous 可缩写为 prev

register 可缩写为 reg

semaphore（信号量） 可缩写为 sem

statistic 可缩写为 stat

synchronize （同步）可缩写为 sync

temp 可缩写为 tmp

add/remove     begin/end   create/destroy

insert/delete   first/last    get/release

increment/decrement   put/get   add/delete

lock/unlock      open/close   min/max

old/new      start/stop    next/previous

source/target    show/hide    send/receive

source/destination  copy/paste   up/down

原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。 

说明：一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。

原则4.2 结构功能单一；不要设计面面俱到的数据结构。

说明：相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。

设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。

原则4.3 不用或者少用全局变量。 

说明：单个文件内部可以使用static的全局变量，可以将其理解为类的私有成员变量。

规则4.1 防止局部变量与全局变量同名。

虽然作用域不同，但人难免有疏忽的时候。

规则4.2 通讯过程中使用的结构，必须注意字节序。

说明：通讯报文中，字节序是一个重要的问题，我司设备使用的cpu类型复杂多样，大小端、32位/64位的处理器也都有，如果结构会在报文交互过程中使用，必须考虑字节序问题。

规则4.3 严禁使用未经初始化的变量作为右值。 

说明：坚持建议4.3（在首次使用前初始化变量，初始化的地方离使用的地方越近越好。）可以有效避免未初始化错误。

建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。

建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。

说明：避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。

建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。 说明：未初始化变量是C和C++程序中错误的常见来源。在变量首次使用前确保正确初始化。

在较好的方案中，变量的定义和初始化要做到亲密无间。

//较好的初始化：使用默认有意义的初始化

int speedup_factor = -1;

if (condition)

{

 speedup_factor = 2;

}

//较好的初始化使用?:减少数据流和控制流的混合

int speedup_factor = condition?2:-1;

//较好的初始化：使用函数代替复杂的计算流

int speedup_factor = ComputeSpeedupFactor()；

建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。 

说明：系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。

建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。 

说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。

示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。

char ch;

unsigned short int exam;

ch = -1;

exam = ch; // 编译器不产生告警，此时exam为0xFFFF。

 

规则5.1 用宏定义表达式时，要使用完备的括号。

示例：如下定义的宏都存在一定的风险

\#define RECTANGLE_AREA(a, b) a * b

\#define RECTANGLE_AREA(a, b) (a * b)

\#define RECTANGLE_AREA(a, b) (a) * (b)

正确的定义应为：

\#define RECTANGLE_AREA(a, b) ((a) * (b))

这是因为：

如果定义#define RECTANGLE_AREA(a, b) a * b 或#define RECTANGLE_AREA(a, b) (a) * (b)

则c/RECTANGLE_AREA(a, b) 将扩展成c/a * b , c 与b 本应该是除法运算，结果变成了乘法运算，

造成错误。

如果定义#define RECTANGLE_AREA(a, b) (a * b)

则RECTANGLE_AREA(c + d, e + f)将扩展成：(c + d * e + f), d与e 先运算，造成错误。

规则5.2 将宏所定义的多条表达式放在大括号中。

说明：更好的方法是多条语句写成do while(0)的方式。

示例：看下面的语句，只有宏的第一条表达式被执行。

\#define FOO(x) \

printf("arg is %d\n", x); \

do_something_useful(x);

为了说明问题，下面for语句的书写稍不符规范

for (blah = 1; blah < 10; blah++)

FOO(blah)

用大括号定义的方式可以解决上面的问题：

\#define FOO(x) { \

printf("arg is %s\n", x); \

do_something_useful(x); \ }

但是如果有人这样调用：

if (condition == 1)

FOO(10);//注意分号

else

FOO(20);

那么这个宏还是不能正常使用，所以必须这样定义才能避免各种问题：

\#define FOO(x) do { \

printf("arg is %s\n", x); \

do_something_useful(x); \

} while(0)

用do-while(0)方式定义宏，完全不用担心使用者如何使用宏，也不用给使用者加什么约束。

规则5.3 使用宏时，不允许参数发生变化。

同时也建议即使函数调用，也不要在参数中做变量变化操作，因为可能引用的接口函数，在某个版本升级后，变成了一个兼容老版本所做的一个宏，结果可能不可预知。

\#define SQUARE(a) ((a) * (a))

int a = 5;

int b;

b = SQUARE(a++); // 结果：a = 7，即执行了两次增

规则5.4 不允许直接使用魔鬼数字。

说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。

使用明确的物理状态或物理意义的名称能增加信息，并能提供单一的维护点。

解决途径：

对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变量命名自注释。

对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。

0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。

建议5.2 常量建议使用const定义代替宏。

建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。 

说明：如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。

示例：在某头文件中定义宏CHECK_AND_RETURN：

\#define CHECK_AND_RETURN(cond, ret) {if (cond == NULL_PTR) {return ret;}}

然后在某函数中使用(只说明问题，代码并不完整):

pMem1 = VOS_MemAlloc(...);

CHECK_AND_RETURN(pMem1 , ERR_CODE_XXX)

pMem2 = VOS_MemAlloc(...);

CHECK_AND_RETURN(pMem2 , ERR_CODE_XXX) /*此时如果pMem2==NULL_PTR，则pMem1未释放函数就返回了，造成内存泄漏。*/

 

原则6.1 代码质量保证优先原则 

（1）正确性，指程序要实现设计要求的功能。

（2）简洁性，指程序易于理解并且易于实现。

（3）可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。

（4）可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。

（5）代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。

（6）代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。

（7）可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。

（8）个人表达方式/个人方便性，指个人编程习惯。

原则6.2 要时刻注意易混淆的操作符。 

说明：包括易混淆和的易用错操作符

1、易混淆的操作符

C语言中有些操作符很容易混淆，编码时要非常小心。

赋值操作符“=” 逻辑操作符“==”

关系操作符“<” 位操作符"<<"

关系操作符“>” 位操作符“>>”

逻辑操作符“||” 位操作符"|"

逻辑操作符“&&” 位操作符"&"

逻辑操作符"!" 位操作符“~”

2、易用错的操作符

(1) 除操作符"/"

当除操作符“/”的运算量是整型量时，运算结果也是整型。

如:1/2=0

(2)求余操作符"%"

求余操作符"%"的运算量只能是整型。

如：5%2=1，而5.0%2是错误的。

(3)自加、自减操作符“++”、“--”

示例1k = 5;

x = k++;

执行后，x = 5，k = 6

示例2k = 5;

x = ++k;

执行后，x = 6，k = 6

原则6.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。

当你运行时，系统才把程序导入内存。一个进程（即运行中的程序）在主要包括以下五个分区：

栈、堆、bss（未手动初始化）、data（已手动初始化）、code

一个由C/C++编译的程序占用的内存分为以下几个部分

1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。

3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放

4、常量存储区 —常量字符串就是放在这里的。 程序结束后由系统释放

5、程序代码区—存放函数体的二进制代码。

原则6.4 不仅关注接口，同样要关注实现。 

说明：这个原则看似和“面向接口”编程思想相悖，但是实现往往会影响接口，函数所能实现的功能，

除了和调用者传递的参数相关，往往还受制于其他隐含约束，如：物理内存的限制，网络状况，具体看“抽象漏洞原则”。

规则6.1 禁止内存操作越界。 

说明：内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，

后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。

示例：使用itoa（）将整型数转换为字符串时：

char TempShold[10] ;

itoa(ProcFrecy,TempShold, 10); /* ，以10进制转换，数据库刷新间隔设为值1073741823时，系统监控后台coredump,监控前台抛异常。*/

TempShold是以‘\0’结尾的字符数组，只能存储9个字符，而ProcFrecy的最大值可达到10位，导致字符数组TempShold越界。

正确写法：一个int（32位）在－2147483647～2147483648之间，将数组TempShold设置成12位。

char TempShold[12] ;

itoa(ProcFrecy,TempShold,10);

坚持下列措施可以避免内存越界：

 数组的大小要考虑最大情况，避免数组分配空间不够。

 避免使用危险函数sprintf /vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数

snprintf/strncpy/strncat/fgets代替。

 使用memcpy/memset时一定要确保长度不要越界

 字符串考虑最后的’\0’， 确保所有字符串是以’\0’结束

 指针加减操作时，考虑指针类型长度

 数组下标进行检查

 使用时sizeof或者strlen计算结构/字符串长度，避免手工计算

规则6.2 禁止内存泄漏。 

说明：内存和资源（包括定时器/文件句柄/Socket/队列/信号量/GUI等各种资源）泄漏是常见的错误。

示例：异常出口处没有释放内存

MsgDBDEV = (PDBDevMsg)GetBuff( sizeof( DBDevMsg ), __LINE__);

if (MsgDBDEV == NULL) 

{

 return; }

MsgDBAppToLogic= (LPDBSelfMsg)GetBuff( sizeof(DBSelfMsg), __LINE__ );

if ( MsgDBAppToLogic == NULL ) 

{

 return; //MsgDB_DEV指向的内存丢失

}

坚持下列措施可以避免内存泄漏：

 异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放

 删除结构指针时，必须从底层向上层顺序删除

 使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了

 避免重复分配内存

 小心使用有return、break语句的宏，确保前面资源已经释放

 检查队列中每个成员是否释放

规则6.3 禁止引用已经释放的内存空间。

说明：在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。

示例：一个函数返回的局部自动存储对象的地址，导致引用已经释放的内存空间

int* foobar (void) 

{ 

int local_auto = 100; 

return &local_auto;

}

坚持下列措施可以避免引用已经释放的内存空间：

 内存释放后，把指针置为NULL；使用内存指针前进行非空判断。

 耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。

 避免操作已发送消息的内存。

 自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象）

规则6.4 编程时，要防止差1错误。 

说明：此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。

使用变量时要注意其边界值的情况。

示例：如C语言中字符型变量，有效值范围为-128到127。故以下表达式的计算存在一定风险。

char ch = 127;

int sum = 200;

ch += 1; // 127为ch的边界值，再加将使ch上溢到-128，而不是128

sum += ch; // 故sum的结果不是328，而是72。

规则6.5 所有的if ... else if结构应该由else子句结束 ；switch语句必须有default分支。 

建议6.1 函数中分配的内存，在函数退出之前要释放。 

说明：有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。

建议6.2 if语句尽量加上else分支，对没有else分支的语句要小心对待。

建议6.3 不要滥用goto语句。 

说明：goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。

可以利用goto语句方面退出多重循环；同一个函数体内部存在大量相同的逻辑但又不方便封装成函数的情况下，譬如反复执行文件操作，对文件操作失败以后的处理部分代码（譬如关闭文件句柄，释放动态申请的内存等等），一般会放在该函数体的最后部分，再需要的地方就goto到那里，这样代码反而变得清晰简洁。

if (p1 == NULL)

 {

 goto Exit0;

 }

……

Exit0:

 free(p1); // C标准规定可以free空指针

 free(p2);

 free(p3);

建议6.4 时刻注意表达式是否会上溢、下溢。 

示例：如下程序将造成变量下溢。

unsigned char size ;

…

while (size-- >= 0) // 将出现下溢

{

 ... // program code

} 当size等于0时，再减不会小于0，而是0xFF，故程序是一个死循环。应如下修改。

char size; // 从unsigned char 改为char

…

while (size-- >= 0)

{

 ... // program code

}

原则7.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。 

本章节后面所有的规则和建议，都应在不影响前述可读性等质量属性的前提下实施。

说明：不能一味地追求代码效率，而对软件的正确、简洁、可维护性、可靠性及可测性造成影响。

这样的代码看起来很清晰，而且也避免了大量的if else嵌套。但是从性能的角度来看，应该把执行概率较大的分支放在前面处理，由于正常情况下的执行概率更大，若首先考虑性能，应如下书写：

int foo() 

{ 

 if (满足条件) 

 { 

 正常处理; 

 return SUCCESS; 

 } 

 else if (概率比较大的异常条件) 

 { 

 异常处理;

 return ERR_CODE_1; 

 } 

 else

 { 

 异常处理;

 return ERR_CODE_2; 

 } 

}

以性能为名，使设计或代码更加复杂，从而导致可读性更差，但是并没有经过验证的性能要求（比如实际的度量数据和目标的比较结果）作为正当理由，本质上对程序没有真正的好处。无法度量的优化行为其实根本不能使程序运行得更快。

记住：让一个正确的程序更快速，比让一个足够快的程序正确，要容易得太多。大多数时候，不要把注意力集中在如何使代码更快上，应首先关注让代码尽可能地清晰易读和更可靠。

原则7.2 通过对数据结构、程序算法的优化来提高效率。

建议7.1 将不变条件的计算移到循环体外。 

说明：将循环中与循环无关，不是每次循环都要做的操作，移到循环外部执行。

示例二：

for (_UL i = 0; i < func_calc_max(); i++)

{

//process;

}

函数func_calc_max()没必要每次都执行，只需要执行一次即可，因此可以改为：

_UL max = func_calc_max();

for (_UL i = 0; i < max; i++)

{

//process;

}

建议7.2 对于多维大数组，避免来回跳跃式访问数组成员。 

示例：多维数组在内存中是从最后一维开始逐维展开连续存储的。下面这个对二维数组访问是以SIZE_B为步长跳跃访问，到尾部后再从头（第二个成员）开始，依此类推。局部性比较差，当步长较大时，

可能造成cache不命中，反复从内存加载数据到cache。应该把i和j交换。

...

for (int i = 0; i < SIZE_B; i++)

{

for (int j = 0; j < SIZE_A; j++)

{

 sum += x[j][i];

} }

...

上面这段代码，在 SIZE_B 数值较大时，效率可能会比下面的代码低: 

...

for (int i = 0; i < SIZE_B; i++)

{

for (int j = 0; j < SIZE_A; j++)

{

 sum += x[i][j]; } }//避免大步长，最好用小步长

建议7.3 创建资源库，以减少分配对象的开销。 

说明：例如，使用线程池机制，避免线程频繁创建、销毁的系统调用；使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用．

建议7.4 将多次被调用的 “小函数”改为inline函数或者宏实现。

说明： 如果编译器支持inline，可以采用inline函数。否则可以采用宏。

在做这种优化的时候一定要注意下面inline函数的优点：其一编译时不用展开，代码SIZE小。其二可以加断点，易于定位问题，例如对于引用计数加减的时候。其三函数编译时，编译器会做语法检查。

三思而后行。

 

原则8.1 优秀的代码可以自我解释，不通过注释即可轻易读懂。 

说明：优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，需要很多注释来解释的代码往往存在坏味道，需要重构。

原则8.2 注释的内容要清楚、明了，含义准确，防止注释二义性。 

说明：有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间。

原则8.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码。

说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释。

注释不是为了名词解释（what），而是说明用途（why）。

对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释，出彩的或复杂的代码块前要加注释，

规则8.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。 

说明：不要将无用的代码留在注释中；随时可以从源代码配置库中找回代码，即使只是想暂时排除代码，也要留个标注，不然可能会忘记处理它。

规则8.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内

容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。 

说明：通常头文件要对功能和用法作简单说明，源文件包含了更多的实现细节或算法讨论。

示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。

/*************************************************

 Copyright © Huawei Technologies Co., Ltd. 1998-2011. All rights reserved. 

 File name: // 文件名

 Author: ID： Version: Date: // 作者、工号、版本及完成日期

 Description: // 用于详细说明此程序文件完成的主要功能，与其他模块

 // 或函数的接口，输出值、取值范围、含义及参数间的控

 // 制、顺序、独立或依赖等关系

 Others: // 其它内容的说明

 History: // 修改历史记录列表，每条修改记录应包括修改日期、修改者及修改内容简述

 \1. Date:

 Author: ID:

 Modification:

 \2. ...

*************************************************/

规则8.3 函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等。

规则8.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明。

规则8.5 注释应放在其代码上方相邻位置或右方，不可放在下面。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同。 

示例：

/* active statistic task number */

\#define MAX_ACT_TASK_NUMBER 1000

\#define MAX_ACT_TASK_NUMBER 1000 /* active statistic task number */

 

可按如下形式说明枚举/数据/联合结构。

/* sccp interface with sccp user primitive message name */

enum SCCP_USER_PRIMITIVE

{

 N_UNITDATA_IND, /* sccp notify sccp user unit data come */

 N_NOTICE_IND, /* sccp notify user the No.7 network can not transmission this message */

 N_UNITDATA_REQ, /* sccp user's unit data transmission request*/

};

规则8.6 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处

理，必须在该case语句处理完、下一个case语句前加上明确的注释。 

说明：这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。

规则8.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写。 

规则8.8 同一产品或项目组统一注释风格。

建议8.1 避免在一行代码或表达式的中间插入注释。 

说明：除非必要，不应在代码或表达中间插入注释，否则容易使代码可理解性变差。

建议8.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言。 

说明：注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。

建议8.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式。 

说明：采用工具可识别的注释格式，例如doxygen格式，方便工具导出注释形成帮助文档。

以doxygen格式为例，文件头，函数和全部变量的注释的示例如下：

文件头注释：

/** 

\* @file （本文件的文件名eg：mib.h） * @brief （本文件实现的功能的简述）

\* @version 1.1 （版本声明）

\* @author （作者，eg：张三）

\* @date （文件创建日期，eg：2010年12月15日）

*/

函数头注释：

/**

*@ Description:向接收方发送SET请求

\* @param req - 指向整个SNMP SET 请求报文.

\* @param ind - 需要处理的subrequest 索引.

\* @return 成功：SNMP_ERROR_SUCCESS，失败：SNMP_ERROR_COMITFAIL

*/

 

规则9.1 程序块采用缩进风格编写，每级缩进为4个空格。 

说明：当前各种编辑器/IDE都支持TAB键自动转空格输入，需要打开相关功能并设置相关功能。

编辑器/IDE如果有显示TAB的功能也应该打开，方便及时纠正输入错误。

IDE向导生成的代码可以不用修改。

宏定义、编译开关、条件预处理语句可以顶格（或使用自定义的排版方案，但产品/模块内必须保持一致）。

规则9.2 相对独立的程序块之间、变量说明之后必须加空行。

规则9.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定。

说明：对于目前大多数的PC来说，132比较合适（80/132是VTY常见的行宽值）；对于新PC宽屏显示器较多的产品来说，可以设置更大的值。

换行时有如下建议：

 换行时要增加一级缩进，使代码可读性更好；

 低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首；

 换行时建议一个完整的语句放在一行，不要根据字符数断行。

规则9.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句。

规则9.5 if、for、do、while、case、switch、default等语句独占一行。

如果if/else配套语句中有一个分支有„{}‟，那么令一个分支即使一行代码也建议增加„{}‟；

添加„{‟的位置可以在if等语句后，也可以独立占下一行；独立占下一行时，可以和if在一个缩进级别，也可以在下一个缩进级别；但是如果if语句很长，或者已经有换行，建议„{‟使用独占一行的写法。

规则9.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－>），后不应加空格。 

说明：采用这种松散方式编写代码的目的是使代码更加清晰。

在已经非常清晰的语句中没有必要再留空格，如括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在C语言中括号已经是最清晰的标志了。

在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。给操作符留空格时不要连续留两个以上空格。

示例：

(1) 逗号、分号只在后面加空格

int a, b, c;

(2) 比较操作符, 赋值操作符"="、 "+="，算术操作符"+"、"%"，逻辑操作符"&&"、"&"，位域操作符

"<<"、"^"等双目操作符的前后加空格。

if (current_time >= MAX_TIME_VALUE) 

a = b + c; 

a *= 2; 

a = b ^ 2;

(3) "!"、"~"、"++"、"--"、"&"（地址操作符）等单目操作符前后不加空格。

*p = 'a'; // 内容操作"*"与内容之间

flag = !is_empty; // 非操作"!"与内容之间

p = &mem; // 地址操作"&" 与内容之间

i++; // "++","--"与内容之间

(4) "->"、"."前后不加空格。

p->id = pid; // "->"指针前后不加空格

(5) if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。

if (a >= b && c > d)

建议9.1 注释符（包括„/*‟„//‟„*/‟）与注释内容之间要用一个空格进行分隔。 

说明：这样可以使注释的内容部分更清晰。

现在很多工具都可以批量生成、删除'//'注释，这样有空格也比较方便统一处理。

建议9.2 源程序中关系较为紧密的代码应尽可能相邻。

 

规则10.1 表达式的值在标准所允许的任何运算次序下都应该是相同的。 

说明：除了少数操作符（函数调用操作符 ( )、&&、| |、? : 和 , （逗号）） 之外，子表达式所依

据的运算次序是未指定的并会随时更改。注意，运算次序的问题不能使用括号来解决，因为这不是优

先级的问题。

将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用。

1、自增或自减操作符

示例：

x = b[i] + i++;

b[i] 的运算是先于还是后于 i ++ 的运算，表达式会产生不同的结果，把自增运算做为单独的语句，

可以避免这个问题。

x = b[i] + i;

i ++;

2﹑函数参数

说明：函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。

示例：

x = func( i++, i);

应该修改代码明确先计算第一个参数：

i++;

x = func(i, i);

3、函数指针

说明：函数参数和函数自身地址的计算次序未定义。

示例：

p->task_start_fn(p++);

求函数地址p与计算p++无关，结果是任意值。必须单独计算p++： p->task_start_fn(p);

p++;

4﹑函数调用

示例：

int g_var = 0;

int fun1() 

{ 

 g_var += 10; 

 return g_var; 

} 

int fun2() 

{ 

 g_var += 100; 

 return g_var; 

} 

int x = fun1() + fun2();

编译器可能先计算fun1()，也可能先计算fun2()，由于x的结果依赖于函数fun1()/fun2()的计算次序

（fun1()/fun2()被调用时修改和使用了同一个全局变量），则上面的代码存在问题。

应该修改代码明确fun1/ fun2的计算次序：

int x = fun1(); 

x = x + fun2();

5、嵌套赋值语句

说明：表达式中嵌套的赋值可以产生附加的副作用。不给这种能导致对运算次序的依赖提供任何机会

的最好做法是，不要在表达式中嵌套赋值语句。

示例：

x = y = y = z / 3; 

x = y = y++;

6、volatile访问

说明：限定符volatile表示可能被其它途径更改的变量，例如硬件自动更新的寄存器。编译器不会优化对volatile变量的读取。

示例：下面的写法可能无法实现作者预期的功能：

/* volume变量被定义为volatile类型*/

UINT16 x = ( volume << 3 ) | volume; /* 在计算了其中一个子表达式的时候，volume的值可能已经被其它程序或硬件改变，导致另外一个子表达式的计算结果非预期，可能无法实现作者预期的功能*/

建议10.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。 

说明：如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：

建议10.2 赋值语句不要写在if等语句中，或者作为函数的参数使用。 

说明：因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。

示例：

int main(int argc, char *argv[], char *envp[])

{

 int a = 0;

 int b;

 if ((a == 0) || ((b = fun1()) > 10))//后面的赋值可能无法被执行到

 {

 printf("a: %d\n", a);

 }

 printf("b: %d\n", b);

}

建议10.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级。

说明：使用括号强调所使用的操作符，防止因默认的优先级与设计思想不符而导致程序出错；同时使得代码更为清晰可读，然而过多的括号会分散代码使其降低了可读性。下面是如何使用括号的建议。

\1. 一元操作符，不需要使用括号

x = ~a; /* 一元操作符，不需要括号*/

x = -a; /* 一元操作符，不需要括号*/

\2. 二元以上操作符，如果涉及多种操作符，则应该使用括号

x = a + b + c; /* 操作符相同，不需要括号*/

x = f ( a + b, c ) /* 操作符相同，不需要括号*/

if (a && b && c) /* 操作符相同，不需要括号*/

x = (a * 3) + c + d; /* 操作符不同，需要括号*/

x = ( a == b ) ? a : ( a –b ); /* 操作符不同，需要括号*/

3 .即使所有操作符都是相同的，如果涉及类型转换或者量级提升，也应该使用括号控制计算的次序

以下代码将3个浮点数相加：

/* 除了逗号(,)，逻辑与(&&)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，以上表达式存在种计算次序：f4 = (f1 + f2) + f3 或f4 = f1 + (f2 + f3)，浮点数计算过程中可能四舍五入，量级提升，计算次序的不同会导致f4的结果不同，以上表达式在不同编译器上的计算结果可能不一样，建议增加括号明确计算顺序*/

f4 = f1 + f2 + f3;

建议10.4 赋值操作符不能使用在产生布尔值的表达式上。 

说明：如果布尔值表达式需要赋值操作，那么赋值操作必须在操作数之外分别进行。这可以帮助避免= 和= =的混淆，帮助我们静态地检查错误。

示例：

x = y; 

if (x != 0) 

{ 

 foo (); 

}

 

规则11.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警。 

说明：编译器是你的朋友，如果它发出某个告警，这经常说明你的代码中存在潜在的问题。

规则11.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略。 

说明：如果必须禁用某个告警，应尽可能单独局部禁用，并且编写一个清晰的注释，说明为什么屏蔽。

某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。

规则11.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致。 

说明：两者一致，避免经过本地构建的代码在持续集成上构建失败。

PC-Lint是一个C/C++软件代码静态分析工具，不仅可以检查一般的语法错误，还可以检查潜在的错误，比如数组访问越界、内存泄漏、使用未初始化变量、使用空指针等。在单元测试前使用PC-Lint来检查代码，可以提前发现程序中的潜在的错误，提高代码的质量。

规则11.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功。 

说明：及时签入代码降低集成难度。

建议11.1 要小心地使用编辑器提供的块拷贝功能编程。

 

原则12.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难。 

说明：单元测试实施依赖于：

 模块间的接口定义清楚、完整、稳定；

 模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）；

 模块内部的关键状态和关键数据可以查询，可以修改；

 模块原子功能的入口唯一；

 模块原子功能的出口唯一；

 依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式。

规则12.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。 

说明：本规则是针对项目组或产品组的。代码至始至终只有一份代码，不存在开发版本和测试版本的说法。测试与最终发行的版本是通过编译开关的不同来实现的。并且编译开关要规范统一。统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关。

说明：统一的调测日志记录便于集成测试，具体包括：

 统一的日志分类以及日志级别；

 通过命令行、网管等方式可以配置和改变日志输出的内容和格式；

 在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位；

 调试日志记录的内容需要包括文件名/模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等。

规则12.3 使用断言记录内部假设。 

说明：断言是对某种内部模块的假设条件进行检查，如果假设不成立，说明存在编程、设计错误。断言可以对在系统中隐藏很深，用其它手段极难发现的问题进行定位，从而缩短软件问题定位时间，提高系统的可测性。

1.使用 assert 的缺点是：频繁的调用会极大的影响程序的性能，增加额外的开销。所以，默认情况下，assert 宏只有在 DEBUG 版本（内部调试版本）中才能够起作用，而在 Release 版本（发行版本）中将被忽略。当然，也可以通过定义宏或设置编译器参数等形式来在任何时候启用或者禁用断言检查。

2.自定义断言来满足需求

实际上，我们经常会出于某种目的，例如：把 assert 宏定义成当发生错误时不是中止调用程序的执行，而是在发生错误的位置转入调试程序，又或者是允许用户选择让程序继续运行等。需要对 assert 宏进行重新定义。

但值得注意的是，不管断言宏最终是用什么样的方式进行定义，其所定义宏的主要目的都是要使用它来对传递给相应函数的参数进行确认检查。如果违背了这条宏定义原则，那么所定义的断言宏将会偏离方向，失去断言宏定义本身的意义。

其次，为不影响标准 assert 宏的使用，最好使用其他的名字。例如，下面的示例代码就展示了用户如何重定义自己的宏 ASSERT。

3.assert 使用风格

l 每个 assert 只检验一个条件。如果同时检验多个条件时，基表断言失败了，我们也无法直观的判断哪个条件失败。

l 不能使用改变环境的表达式：断言仅用于判断条件是否正确，不应参与任何运算。

l assert 和后面的语句应该空一行，以形成逻辑和视觉上的一致性。

l 断言用于检查 “不应该” 发生的情况，不能代替条件过滤。

l 放在函数参数的入口处检查传入参数的合法性：

规则12.4 不能用断言来检查运行时错误。

说明：断言是用来处理内部编程或设计是否符合假设；不能处理对于可能会发生的且必须处理的情况要写防错程序，而不是断言。如某模块收到其它模块或链路上的消息后，要对消息的合理性进行检查，此过程为正常的错误检查，不能用断言来实现。

断言的使用是有条件的。断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断,因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。

建议12.1 为单元测试和系统故障注入测试准备好方法和通道。

 

**代码的安全漏洞大都是由代码缺陷导致，但不是所有代码缺陷都有安全风险。理解安全漏洞产生的原理和如何进行安全编码是减少软件安全问题最直接有效的办法。**

原则13.1 对用户输入进行检查。 

说明：不能假定用户输入都是合法的，因为难以保证不存在恶意用户，即使是合法用户也可能由于误用误操作而产生非法输入。用户输入通常需要经过检验以保证安全，特别是以下场景：

 用户输入作为循环条件

 用户输入作为数组下标

 用户输入作为内存分配的尺寸参数

 用户输入作为格式化字符串

 用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化）

这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题。

可采取以下措施对用户输入检查：

 用户输入作为数值的，做数值范围检查

 用户输入是字符串的，检查字符串长度

用户输入作为格式化字符串的，检查关键字“%”  

用户输入作为业务数据，对关键字进行检查、转义

规则13.1 确保所有字符串是以NULL结束。

说明：C语言中‟\0‟作为字符串的结束符，即NULL结束符。标准字符串处理函数（如strcpy()、strlen()）依赖NULL结束符来确定字符串的长度。没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。

为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：

 用strncpy()代替strcpy()

 用strncat()代替strcat()

 用snprintf()代替sprintf()

 用fgets()代替gets()

这些函数会截断超出指定限制的字符串，但是要注意它们并不能保证目标字符串总是以NULL结尾。如果源字符串的前n个字符中不存在NULL字符，目标字符串就不是以NULL结尾。

示例：

char a[16];

strncpy(a, "0123456789abcdef", sizeof(a));

上述代码存在安全风险：在调用strncpy()后，字符数组a中的字符串是没有NULL结束符的，也没有空间存放NULL结束符。

正确写法：截断字符串，保证字符串以NULL结束。

char a[16];

strncpy(a, "0123456789abcdef", sizeof(a) - 1 );

a[sizeof(a) - 1] = '\0';

规则13.2 不要将边界不明确的字符串写到固定长度的数组中。 

说明：边界不明确的字符串（如来自gets()、getenv()、scanf()的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。

示例：

char buff[256];

char *editor = getenv("EDITOR");

if (editor != NULL) 

{

 strcpy(buff, editor);

}

上述代码读取环境变量"EDITOR"的值，如果成功则拷贝到缓冲区buff中。而从环境变量获取到的字符串长度是不确定的，把它们拷贝到固定长度的数组中很可能导致缓冲区溢出。

正确写法：计算字符串的实际长度，使用malloc分配指定长度的内存

char *buff;

char *editor = getenv("EDITOR");

if (editor != NULL) 

{

 buff = （char *）malloc(strlen(editor) + 1);//注意是strlen，如果是sizeof则只能得到char*宽度而不能得到实际长度。

 if (buff != NULL) 

 {

 strcpy(buff, editor);

 } }

C99标准定义了整型提升（integer promotions）、整型转换级别（integer conversion rank）以及普通算术转换（usual arithmetic conversions）的整型操作。不过这些操作实际上也带来了安全风险。

规则13.3 避免整数溢出。 

说明：当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。

带符号和无符号的数都有可能发生溢出。

规则13.5：避免截断错误。 

说明：将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错

误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失。

使用截断后的变量进行内存操作，很可能会引发问题。

示例：

int main(int argc, char* argv[])

{

 unsigned short total = strlen(argv[1]) + strlen(argv[2]) + 1;

 char* buffer = (char*)malloc(total);

 strcpy(buffer, argv[1]);

 strcat(buffer, argv[2]);

 free(buffer);

return 0;

}

示例代码中total被定义为unsigned short，相对于strlen()的返回值类型size_t（通常为unsigned long）太小。如果攻击者提供的两个入参长度分别为65500和36，unsigned long的65500+36+1会被取模截断，total的最终值是（65500+36+1）%65536 = 1。malloc()只为buff分配了1字节空间，为strcpy()和strcat()的调用创造了缓冲区溢出的条件。

正确写法：将涉及到计算的变量声明为统一的类型，并检查计算结果。

int main(int argc, char* argv[])

{

 size_t total = strlen(argv[1]) + strlen(argv[2]) + 1;

 if ((total <= strlen(argv[1])) || (total <= strlen(argv[2])))

 {

 /* handle error */

 return -1;

}

char* buffer = (char*)malloc(total);

 strcpy(buffer, argv[1]);

strcat(buffer, argv[2]);

free(buffer);

return 0;

}

13.3格式化输出安全

规则13.6：确保格式字符和参数匹配。 

说明：使用格式化字符串应该小心，确保格式字符和参数之间的匹配，保留数量和数据类型。格式字符和参数之间的不匹配会导致未定义的行为。大多数情况下，不正确的格式化字符串会导致程序异常终止。

错误示例：

char *error_msg = "Resource not available to user.";

int error_type = 3;

/* 格式字符和参数的类型不匹配*/

printf("Error (type %s): %d\n", error_type, error_msg);

/* 格式字符和参数的数量不匹配*/

printf("Error: %s\n");

正确做法：格式化字符串由代码确定，未经检查过滤的用户输入只能作为参数。

void check_password(char *user, char *password) 

{

 if (strcmp(password(user), password) != 0) 

 {

 char *msg = malloc(strlen(user) + 100);

 if (!msg)

 {

 /* handle error condition */

 }

 sprintf(msg, "%s password incorrect", user);

 fprintf(stderr, "%s", user);

 syslog(LOG_INFO, "%s", msg);

 free(msg);

 } }

规则13.9 使用int类型变量来接受字符I/O函数的返回值。 

说明：字符I/O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fputc()、putc()、putchar()和ungetc()也返回一个字符或EOF。

如果这些I/O函数的返回值需要与EOF进行比较，不要将返回值转换为char类型。因为char是有符号8位的值，int是32位的值。如果getchar()返回的字符的ASCII值为0xFF，转换为char类型后将被解释为EOF。因为这个值被有符号扩展为0xFFFFFFFF（EOF的值）执行比较。

示例：

char buf[BUF_SIZE];

char ch;

int i = 0;

while ( (ch = getchar()) != '\n' && ch != EOF ) 

{

 if ( i < BUF_SIZE - 1 )

 {

 buf[i++] = ch;

 } }

buf[i] = '\0'; /* terminate NTBS */

正确做法：使用int类型的变量接受getchar()的返回值。

char buf[BUF_SIZE];

int ch;

int i = 0;

while (((ch = getchar()) != '\n') && ch != EOF) 

{

 if (i < BUF_SIZE - 1)

{

 buf[i++] = ch;

 } }

buf[i] = '\0'; /* terminate NTBS */

对于sizeof(int) == sizeof(char)的平台，用int接收返回值也可能无法与EOF区分，这时要用feof()和ferror()检测文件尾和文件错误。

 

规则15.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数。 

建议15.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。 

说明：使用标准的数据类型，有利于程序的移植。

示例：如下例子（在DOS下BC3.1环境中），在移植时可能产生问题。

void main()

{

 register int index; // 寄存器变量

 _AX = 0x4000; // _AX是BC3.1提供的寄存器“伪变量”

 ... // program code

}

建议15.2 除非为了满足特殊需求，避免使用嵌入式汇编。 

说明：程序中嵌入式汇编，一般都对可移植性有较大的影响

 



特意声明，本笔记仅作为学习参考所用。

主要参考：

《华为技术有限公司C语言编程规范》，如有侵权，请联系删除。